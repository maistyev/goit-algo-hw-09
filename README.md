# Аналіз алгоритмів розміну монет

## Порівняння алгоритмів

### Жадібний алгоритм (`find_coins_greedy`)

#### Переваги:
1. **Простота реалізації**: Алгоритм легко зрозуміти та реалізувати
2. **Швидкодія**: O(n), де n - кількість номіналів монет
3. **Ефективне використання пам'яті**: O(1) додаткової пам'яті
4. **Швидка робота з великими сумами**: Час виконання практично не залежить від розміру суми

#### Недоліки:
1. **Не завжди оптимальний результат**: Може видати більшу кількість монет, ніж потрібно
2. **Обмежена застосовність**: Працює оптимально тільки для певних наборів номіналів монет

### Алгоритм динамічного програмування (`find_min_coins`)

#### Переваги:
1. **Гарантовано оптимальний результат**: Завжди знаходить мінімальну кількість монет
2. **Універсальність**: Працює з будь-якими наборами номіналів монет
3. **Можливість відновлення повного шляху**: Можна відстежити, які саме монети були використані

#### Недоліки:
1. **Більша складність реалізації**: Потребує більше коду та уважності при реалізації
2. **Повільніша робота з великими сумами**: O(n*m), де n - сума, m - кількість номіналів монет
3. **Більше використання пам'яті**: O(n) додаткової пам'яті

## Результати тестування

Для набору монет `[50, 25, 10, 5, 2, 1]` та різних сум було проведено порівняльне тестування:

1. **Для малих сум (до 100)**: 
   - Обидва алгоритми працюють дуже швидко
   - Різниця в часі виконання практично непомітна
   - Часто дають однакові результати

2. **Для середніх сум (100-1000)**:
   - Жадібний алгоритм продовжує працювати стабільно швидко
   - Динамічний алгоритм показує незначне сповільнення
   - Можуть з'являтися відмінності в результатах

3. **Для великих сум (>1000)**:
   - Жадібний алгоритм зберігає високу швидкодію
   - Динамічний алгоритм показує помітне сповільнення
   - Різниця в часі виконання стає значною

## Висновки

1. **Для даного набору монет**:
   - Жадібний алгоритм є оптимальним вибором
   - Він дає правильні результати завдяки специфіці набору номіналів
   - Має кращу продуктивність особливо на великих сумах

2. **Для загального випадку**:
   - Якщо важлива гарантована оптимальність - варто використовувати динамічне програмування
   - Якщо важлива швидкодія і допустимі неоптимальні результати - краще використовувати жадібний алгоритм
   - При роботі з великими сумами жадібний алгоритм має значну перевагу в продуктивності

3. **Рекомендації щодо використання**:
   - Для касових апаратів з даним набором монет оптимально використовувати жадібний алгоритм
   - Для систем, де набір номіналів може змінюватися, краще використовувати динамічне програмування
   - При обмеженнях на пам'ять перевагу варто віддати жадібному алгоритму